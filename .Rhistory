test[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m < t$m))
print(prev_inflection_point)
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
test[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
# Iterate through rows of test and identify the previous and next inflection
# points
for(i in 1:length(test$m)) {
print(paste("test row: ", i))
# Subset test for the current record
t <- test[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- test[test$dist < 0.2, c("m","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$m >= t$m)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$m)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$m
n_inf <- inf[inf$m > next_m - 1 & inf$m < next_m + 1,]
# Write the m value of the next inflection point
test[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m <= t$m))
print(prev_inflection_point)
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
test[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
plot(flowline_points_sf$POINT_M[1000:2000], flowline_points_sf$distance_ft[1000:2000])
library(arcgisbinding)
arc.check_product()
library(sp)
library(sf)
library(units)
# Source hydraulic geometry functions
source("//mvrdfs/egis/Work/Office/Regional/ERDC/EMRRP_Sediment/Methods/FluvialGeomorphr/HydraulicGeometry2.R")
flowline_points_fc <- "//mvrdfs/egis/Work/Office/Regional/ERDC/EMRRP_Sediment/Senachwine/Data/Watershed/01_LowerSenachwineCreek/LowerSenachwineCreek.gdb/flowline_points"
valley_line_fc <- "//mvrdfs/egis/Work/Office/Regional/ERDC/EMRRP_Sediment/Senachwine/Data/Watershed/01_LowerSenachwineCreek/LowerSenachwineCreek.gdb/flowline_500"
# Import fc to sp
flowline_points <- arc2sp(flowline_points_fc)
valley_line     <- arc2sp(valley_line_fc)
# Convert to data frame
flowline_pts <- data.frame(flowline_points@data)
# Convert sp to `sf` object
flowline_points_sf <- st_as_sf(flowline_points)
valley_line_sf     <- st_as_sf(valley_line)
# Calculate distance between flowline_points and valley_line
flowline_points_sf$distance_ft <- drop_units(st_distance(flowline_points_sf, valley_line_sf)) * 3.28084
plot(flowline_points_sf$POINT_M[1000:2000], flowline_points_sf$distance_ft[1000:2000])
plot(x = flowline_points_sf$POINT_M[1000:2000],
y = flowline_points_sf$distance_ft[1000:2000],
type = "l")
View(RHG)
find_inflections <- function(data) {
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$m)) {
print(paste("Row: ", i))
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- data[data$dist < 0.2, c("m","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$m >= t$m)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$m)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$m
n_inf <- inf[inf$m > next_m - 1 & inf$m < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m <= t$m))
print(prev_inflection_point)
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
return(data)
}
test2 <- find_inflections(test)
test2 <- find_inflections(test)
find_inflections <- function(data) {
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$m)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- data[data$dist < 0.2, c("m","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$m >= t$m)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$m)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$m
n_inf <- inf[inf$m > next_m - 1 & inf$m < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m <= t$m))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
return(data)
}
test2 <- find_inflections(test)
find_inflections <- function(data) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$m)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- data[data$dist < 0.2, c("m","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$m >= t$m)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$m)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$m
n_inf <- inf[inf$m > next_m - 1 & inf$m < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m <= t$m))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
return(data)
}
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(m = m,
dist = abs(sin(m)))
plot(test$m, test$dist, type="l")
find_inflections <- function(data) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$m)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- data[data$dist < 0.2, c("m","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$m >= t$m)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$m)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$m
n_inf <- inf[inf$m > next_m - 1 & inf$m < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
## Find the previous inflection point
prev_inflection_point <- length(which(inf$m <= t$m))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$m
n_inf <- inf[inf$m > prev_m -1 & inf$m < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$m
}
return(data)
}
test2 <- find_inflections(test)
View(test2)
View(flowline_points_sf)
# Convert sp to `sf` object
flowline_points_sf <- st_as_sf(flowline_points)
valley_line_sf     <- st_as_sf(valley_line)
# Calculate distance between flowline_points and valley_line
flowline_points_sf$dist <- drop_units(st_distance(flowline_points_sf, valley_line_sf)) * 3.28084
plot(x = flowline_points_sf$POINT_M[1000:2000],
y = flowline_points_sf$dist[1000:2000],
type = "l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist = abs(sin(m)))
plot(test$m, test$dist, type="l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist = abs(sin(m)))
plot(test$POINT_M, test$dist, type="l")
find_inflections <- function(data) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 0.2 are considered a potential inflection point
inf <- data[data$dist < 0.2, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(test)
flowline_points_sf_inf <- find_inflections(flowline_points_sf)
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:1000,])
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100,])
View(flowline_points_sf_inf)
rm(test2)
test2 <- find_inflections(test)
View(test2)
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100, -geometry])
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100, c(-geometry)])
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100, c(-"geometry")])
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100, -7])
flowline_points_sf_inf <- find_inflections(flowline_points_sf[1:100,])
find_inflections <- function(data) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < 1.0, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, inflection_distance = 0.2)
find_inflections <- function(data, inflection_distance) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < inflection_distance, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, inflection_distance = 0.2)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:1000,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 10.0)
plot(x = flowline_points_sf$POINT_M[1:100],
y = flowline_points_sf$dist[1:100],
type = "l")
find_inflections <- function(data, inf_dist) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < inf_dist, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, inf_dist = 0.2)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inf_dist = 1.0)
View(test2)
find_inflections <- function(data, vl_dist, rt_dist) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < vl_dist, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - rt_dist &
inf$POINT_M < next_m + rt_dist,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m - rt_dist &
inf$POINT_M < prev_m + rt_dist,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, vl_dist = 0.2, rt_dist = 1)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.002)
# Convert sp to `sf` object
flowline_points_sf <- st_as_sf(flowline_points)
valley_line_sf     <- st_as_sf(valley_line)
# Calculate distance between flowline_points and valley_line
flowline_points_sf$dist_vl <- drop_units(st_distance(flowline_points_sf, valley_line_sf)) * 3.28084
plot(x = flowline_points_sf$POINT_M[1:100],
y = flowline_points_sf$dist_vl[1:100],
type = "l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist = abs(sin(m)))
plot(test$POINT_M, test$dist_vl, type="l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist_vl = abs(sin(m)))
plot(test$POINT_M, test$dist_vl, type="l")
find_inflections <- function(data, vl_dist, rt_dist) {
# Computes the m-value of the next and previous crossing points inflection pointscross sectional area, width, depth,
# discharge) from a built-in table of regional hydraulic equation
# coefficients.
#
# Args:
#    region:         character; The region that a dimension will be
#                    calculated for. For a complete list of names, see the
#                    regional_curve_equation$region_name field
#    drainageArea:   numeric; The upstream drainage area of the location of
#                    the dimension (in square miles).
#    dimensionType:  character; Dimension type: "area", "depth", "width",
#                    "discharge"
#
# Returns:
#    the value of the requested hydraulic dimension
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist_vl < vl_dist, c("POINT_M","dist_vl")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - rt_dist &
inf$POINT_M < next_m + rt_dist,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist_vl ==
min(n_inf$dist_vl),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m - rt_dist &
inf$POINT_M < prev_m + rt_dist,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist ==
min(n_inf$dist_vl),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, vl_dist = 0.2, rt_dist = 1)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.002)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.001)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:1000,],
vl_dist = 1.0,
rt_dist = 0.001)
library(devtools)
has_dev()
has_devel()
library(igraph)
?graph_from_adjacency_matrix
