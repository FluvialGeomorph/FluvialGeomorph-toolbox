# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, inflection_distance = 0.2)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:1000,],
inflection_distance = 1.0)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inflection_distance = 10.0)
plot(x = flowline_points_sf$POINT_M[1:100],
y = flowline_points_sf$dist[1:100],
type = "l")
find_inflections <- function(data, inf_dist) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < inf_dist, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - 1 & inf$POINT_M < next_m + 1,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m -1 & inf$POINT_M < prev_m + 1,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, inf_dist = 0.2)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
inf_dist = 1.0)
View(test2)
find_inflections <- function(data, vl_dist, rt_dist) {
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist < vl_dist, c("POINT_M","dist")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - rt_dist &
inf$POINT_M < next_m + rt_dist,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m - rt_dist &
inf$POINT_M < prev_m + rt_dist,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist == min(n_inf$dist),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, vl_dist = 0.2, rt_dist = 1)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.002)
# Convert sp to `sf` object
flowline_points_sf <- st_as_sf(flowline_points)
valley_line_sf     <- st_as_sf(valley_line)
# Calculate distance between flowline_points and valley_line
flowline_points_sf$dist_vl <- drop_units(st_distance(flowline_points_sf, valley_line_sf)) * 3.28084
plot(x = flowline_points_sf$POINT_M[1:100],
y = flowline_points_sf$dist_vl[1:100],
type = "l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist = abs(sin(m)))
plot(test$POINT_M, test$dist_vl, type="l")
# Create test dataset
m <- seq(0,15,length.out=100)
test <- data.frame(POINT_M = m,
dist_vl = abs(sin(m)))
plot(test$POINT_M, test$dist_vl, type="l")
find_inflections <- function(data, vl_dist, rt_dist) {
# Computes the m-value of the next and previous crossing points inflection pointscross sectional area, width, depth,
# discharge) from a built-in table of regional hydraulic equation
# coefficients.
#
# Args:
#    region:         character; The region that a dimension will be
#                    calculated for. For a complete list of names, see the
#                    regional_curve_equation$region_name field
#    drainageArea:   numeric; The upstream drainage area of the location of
#                    the dimension (in square miles).
#    dimensionType:  character; Dimension type: "area", "depth", "width",
#                    "discharge"
#
# Returns:
#    the value of the requested hydraulic dimension
# Create new fields to hold the m values of the inflection points
data$prev_inf_m <- 0
data$next_inf_m <- 0
# Iterate through rows of test and identify the previous and next
# inflection points
for(i in 1:length(data$POINT_M)) {
# Subset test for the current record
t <- data[i,]
## Create a table of potential inflection points
# dist values within 1.0 feet are considered a potential inflection
# point
inf <- data[data$dist_vl < vl_dist, c("POINT_M","dist_vl")]
## Find the next inflection point
next_inflection_index <- which(inf$POINT_M >= t$POINT_M)[1]
# Handle the end of the series
if(is.na(next_inflection_index)) {
next_inflection_index <- length(inf$POINT_M)
}
# Find inflections close to this value
next_m <- inf[next_inflection_index,]$POINT_M
n_inf <- inf[inf$POINT_M > next_m - rt_dist &
inf$POINT_M < next_m + rt_dist,]
# Write the m value of the next inflection point
data[i,]$next_inf_m <- n_inf[n_inf$dist_vl ==
min(n_inf$dist_vl),]$POINT_M
## Find the previous inflection point
prev_inflection_point <- length(which(inf$POINT_M <= t$POINT_M))
# Find inflections close to this value
prev_m <- inf[prev_inflection_point,]$POINT_M
n_inf <- inf[inf$POINT_M > prev_m - rt_dist &
inf$POINT_M < prev_m + rt_dist,]
# Write the m value of the previous inflection point
data[i,]$prev_inf_m <- n_inf[n_inf$dist ==
min(n_inf$dist_vl),]$POINT_M
}
return(data)
}
test2 <- find_inflections(data = test, vl_dist = 0.2, rt_dist = 1)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.002)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:100,],
vl_dist = 1.0,
rt_dist = 0.001)
flowline_points_sf_inf <- find_inflections(data = flowline_points_sf[1:1000,],
vl_dist = 1.0,
rt_dist = 0.001)
library(devtools)
has_dev()
has_devel()
library(igraph)
?graph_from_adjacency_matrix
?require
devtools::install_github(repo = "mpdougherty/RegionalCurve",
dependencies = TRUE)
?devtools::install_github
sessionInfo()
install.packages(c("dplyr", "lintr", "pkgload", "ps", "raster", "rcmdcheck", "remotes", "roxygen2", "sessioninfo", "stringi", "tidyr"))
install.packages(c("raster", "rcmdcheck"))
install.packages("ps")
install.packages(c("raster", "rcmdcheck"))
update.packages()
update.packages()
paste(.libPaths())
.libPaths()
as.character(.libPaths())
is.character(.libPaths())
paste("R libsPath: ", .libPaths())
message(paste("R libsPath: ", .libPaths()))
message(paste("R libsPath: ", .libPaths()), " ")
message(paste("R libsPath: ", .libPaths()))
?paste
message(paste("R libsPath: ", .libPaths(), collapse = " "))
message(paste("R libsPath: ", .libPaths(), collapse = "\n"))
R.version
sessionInfo()
?sessionInfo
sessionInfo()
devtools::session_info
# Install devtools
if(!require("devtools")) {
install.packages("devtools", dependencies = TRUE)
if("devtools" %in% rownames(installed.packages()) == TRUE) {
message("The `devtools` package was installed.")
}
}
devtools::session_info()
devtools::package_info(c("fgm", "RegionalCurve"))
?print
message(devtools::package_info("RegionalCurve"))
print(devtools::package_info("RegionalCurve"))
print(devtools::package_info(pkgs = c("RegionalCurve", "fgm")))
print(devtools::package_info(pkgs = c(RegionalCurve, fgm)))
print(devtools::package_info(pkgs = c("RegionalCurve", "fgm")))
?devtools::package_info
?c
?rmarkdown::pandoc_available
rmarkdown::pandoc_available()
rmarkdown::pandoc_version()
Sys.getenv()
Sys.which("pandoc")
system('pandoc -v')==0
Sys.which("pandoc")
pandoc_paths <- c("pandoc")
Sys.which(pandoc_paths)
pandoc_paths <- c("pandoc",
"C:/Program Files/RStudio/bin/pandoc")
Sys.which(pandoc_paths)
?Sys.which
pandoc_paths <- c("pandoc",
"C:/Program Files/pandoc/bin",
"C:/Program Files/RStudio/bin/pandoc")
Sys.which(pandoc_paths)
Sys.which(c("ftp", "ping", "texi2dvi", "this-does-not-exist"))
pandoc_paths <- c(#"pandoc",
#"C:/Program Files/pandoc/bin",
"C:/Program Files/RStudio/bin/pandoc")
Sys.which(pandoc_paths)
pandoc_paths <- c(#"pandoc",
#"C:/Program Files/pandoc/bin",
"perl",
"C:/Program Files/RStudio/bin/pandoc")
Sys.which(pandoc_paths)
pandoc_paths <- c(#"pandoc",
#"C:/Program Files/pandoc/bin",
"perl",
"C:\\Program Files\\RStudio\\bin\\pandoc")
Sys.which(pandoc_paths)
pandoc_paths <- c(#"pandoc",
#"C:/Program Files/pandoc/bin",
"perl",
"C:\\Program Files\\RStudio\\bin\\pandoc.exe")
Sys.which(pandoc_paths)
Sys.which("pandoc")
?file.exists
Sys.which(perl)
Sys.which("perl")
Sys.which("perl")[1]
Sys.which("perl")[2]
?basename
dirname(Sys.which("perl"))
!Sys.which("perl") == ""
!Sys.which("perl") == 0
?devtools::install_github
?devtools::install_local
?require
?install.packages
?remove.packages
attr(sessionInfo()$otherPkgs$devtools, "file")
attr(sessionInfo()$otherPkgs$fgm, "file")
sessionInfo()$otherPkgs$fgm
sessionInfo()
devtools::package_info("fgm")
rc <- devtools::package_info("RegionalCurve")
?installed.packages
file.exists("C:/Program Files/RStudio/bin/pandoc.exe"
)
file.exists("C:\\Program Files\\RStudio\\bin\\pandoc.exe")
R.version
devtools::install_local("//mvrdfs//egis//Work//Office//Regional//ERDC/EMRRP_Sediment//Methods//fgm_0.1.0.zip",
force = TRUE,
upgrade = TRUE,
dependencies = TRUE)
devtools::install_local("//mvrdfs//egis//Work//Office//Regional//ERDC/EMRRP_Sediment//Methods//fgm_0.1.0.zip",
force = TRUE,
upgrade = TRUE,
dependencies = TRUE)
?devtools::install_local
install.packages("readr")
library(arcgisbinding)
arc.check_product()
xs_fc              <- "//mvrdfs/egis/Work/Office/Regional/ERDC/EMRRP_Sediment/Senachwine/Data/Watershed/01_LowerSenachwineCreek/LowerSenachwineCreek.gdb/riffle"
xs_points_fc       <- "//mvrdfs/egis/Work/Office/Regional/ERDC/EMRRP_Sediment/Senachwine/Data/Watershed/01_LowerSenachwineCreek/LowerSenachwineCreek.gdb/riffle_points"
bankfull_elevation <- 103
lead_lag           <- 1
use_smoothing      <- TRUE
loess_span         <- 1
# Convert ArcGIS fc to sp format
xs        <- fgm::arc2sp(xs_fc)
xs_points <- fgm::arc2sp(xs_points_fc)
# Create a list to hold the xs dimensions
xs_geoms_ss <- list()
xs_geoms    <- list()
# Iterate through xs ReachNames
for (g in unique(xs_points$ReachName)) {
# Subset xs for the current reach
xs_reach <- xs@data[xs$ReachName == g, ]
# Calculate slope and sinuosity for xs_reach
xs_reach_ss <- fgm::slope_sinuosity(xs_reach,
lead_lag = lead_lag,
use_smoothing = use_smoothing,
loess_span = loess_span)
xs_geoms_ss[[g]] <- xs_reach_ss
# Iterate through xs's and calculate dimensions
for (i in xs[xs$ReachName == g, ]$Seq) {
# Subset for the current stream and convert to data frame
xs_pts <- xs_points@data[xs_points$ReachName == g, ]
# Calculate xs dimensions
dims <- fgm::xs_metrics(xs_points = xs_pts,
stream = g,
xs_number = i,
bankfull_elevation = bankfull_elevation)
xs_geoms[[i]] <- dims
}
}
# Append the list of xs dimensions into a single data frame
# (slope_sinuosity)
reach_geoms <- dplyr::bind_rows(xs_geoms_ss)
# Append the list of xs_points dimensions into a singe data frame
# (xs_dimensions)
xs_reach_geoms <- dplyr::bind_rows(xs_geoms)
# Join reach_geoms and xs_reach_geoms
dims_join <- merge(x = reach_geoms,
y = xs_reach_geoms,
by.x = "Seq", by.y = "cross_section")
library(fgm)
# Create a list to hold the xs dimensions
xs_geoms_ss <- list()
xs_geoms    <- list()
# Iterate through xs ReachNames
for (g in unique(xs_points$ReachName)) {
# Subset xs for the current reach
xs_reach <- xs@data[xs$ReachName == g, ]
# Calculate slope and sinuosity for xs_reach
xs_reach_ss <- fgm::slope_sinuosity(xs_reach,
lead_lag = lead_lag,
use_smoothing = use_smoothing,
loess_span = loess_span)
xs_geoms_ss[[g]] <- xs_reach_ss
# Iterate through xs's and calculate dimensions
for (i in xs[xs$ReachName == g, ]$Seq) {
# Subset for the current stream and convert to data frame
xs_pts <- xs_points@data[xs_points$ReachName == g, ]
# Calculate xs dimensions
dims <- fgm::xs_metrics(xs_points = xs_pts,
stream = g,
xs_number = i,
bankfull_elevation = bankfull_elevation)
xs_geoms[[i]] <- dims
}
}
# Append the list of xs dimensions into a single data frame
# (slope_sinuosity)
reach_geoms <- dplyr::bind_rows(xs_geoms_ss)
# Append the list of xs_points dimensions into a singe data frame
# (xs_dimensions)
xs_reach_geoms <- dplyr::bind_rows(xs_geoms)
# Join reach_geoms and xs_reach_geoms
dims_join <- merge(x = reach_geoms,
y = xs_reach_geoms,
by.x = "Seq", by.y = "cross_section")
library(sp)
library(dplyr)
library(fgm)
# Create a list to hold the xs dimensions
xs_geoms_ss <- list()
xs_geoms    <- list()
# Iterate through xs ReachNames
for (g in unique(xs_points$ReachName)) {
# Subset xs for the current reach
xs_reach <- xs@data[xs$ReachName == g, ]
# Calculate slope and sinuosity for xs_reach
xs_reach_ss <- fgm::slope_sinuosity(xs_reach,
lead_lag = lead_lag,
use_smoothing = use_smoothing,
loess_span = loess_span)
xs_geoms_ss[[g]] <- xs_reach_ss
# Iterate through xs's and calculate dimensions
for (i in xs[xs$ReachName == g, ]$Seq) {
# Subset for the current stream and convert to data frame
xs_pts <- xs_points@data[xs_points$ReachName == g, ]
# Calculate xs dimensions
dims <- fgm::xs_metrics(xs_points = xs_pts,
stream = g,
xs_number = i,
bankfull_elevation = bankfull_elevation)
xs_geoms[[i]] <- dims
}
}
# Append the list of xs dimensions into a single data frame
# (slope_sinuosity)
reach_geoms <- dplyr::bind_rows(xs_geoms_ss)
# Append the list of xs_points dimensions into a singe data frame
# (xs_dimensions)
xs_reach_geoms <- dplyr::bind_rows(xs_geoms)
# Join reach_geoms and xs_reach_geoms
dims_join <- merge(x = reach_geoms,
y = xs_reach_geoms,
by.x = "Seq", by.y = "cross_section")
# Remove fields from dims_join already on xs
dims_join_reduced <- dims_join[, ]
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
dims_join_reduced <- dims_join[, -c("OBJECTID")]
?select
dims_join_reduced <- dims_join[, -2:11]
names(xs@data)
# Remove fields from dims_join already on xs
xs_names <- names(xs@data)
dims_join_reduced <- select(dims_join, -xs_names)
xs_names
?names
xs_names[-"Seq"]
xs_names[!"Seq" %in% xs_names]
xs_names[!"Seq"]
xs_names[xs_names != "Seq"]
# Get the list of names for xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Remove the uneeded fields
dims_join_reduced <- select(dims_join, -xs_names)
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
# Remove fields from dims_join already on xs
# Get the list of names from xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Remove other fields
names(xs_names) <- "reach_name"
# Remove the uneeded fields
dims_join_reduced <- select(dims_join, -xs_names)
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
xs_names <- names(xs@data)
xs_names
xs_names <- xs_names[xs_names != "Seq"]
xs_names
names(xs_names) <- "reach_name"
xs_names
# Remove fields from dims_join already on xs
# Get the list of names from xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Add other fields to be removed
append(xs_names, "reach_name")
# Remove fields from dims_join already on xs
# Get the list of names from xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Add other fields to be removed
append(xs_names, "reach_name")
# Remove the uneeded fields
dims_join_reduced <- select(dims_join, -xs_names)
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
xs_names
# Remove fields from dims_join already on xs
# Get the list of names from xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Add other fields to be removed
xs_names <- append(xs_names, "reach_name")
# Remove the uneeded fields
dims_join_reduced <- select(dims_join, -xs_names)
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
# Remove fields from dims_join already on xs
# Get the list of names from xs
xs_names <- names(xs@data)
# Retain the field `Seq` for the join
xs_names <- xs_names[xs_names != "Seq"]
# Add other fields to be removed
xs_names <- append(xs_names, c("reach_name", "xs_type"))
# Remove the uneeded fields
dims_join_reduced <- select(dims_join, -xs_names)
# Join the reach_geoms to xs_fc
xs_dims <- sp::merge(xs, dims_join_reduced, by.x = "Seq", by.y = "Seq")
?loess
